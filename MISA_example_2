import numpy as np
import random as rn
import pandas as pd
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from MISA_example import MISA_ODE_general, positive_regulation, negative_regulation,solve_misa_ode,MISA_ODE_test
from scipy.linalg import eigh
from scipy.stats import multivariate_normal

misa_params=[]
with open("MISA.prs", "r") as f:
    next(f)  # skip the first line
    for line in f:
        if line.strip():  # skip empty lines
            misa_params.append(line.strip().split()[0])

header_names = ['Number of SS']
header_names.extend(misa_params)
param_sets = pd.read_csv('MISA_parameters.csv', header=None, names=header_names)


solutions=pd.read_csv('MISA_solution.csv', header=None, names=['S.No','No. of SS','No. of Init Conds', 'A', 'B'])


state_of_interest=(solutions[solutions['S.No']==510]) 
print(state_of_interest)
param_interest=(param_sets.iloc[state_of_interest['S.No'].values[0]]).drop('Number of SS')
steady_states=[]
freq_ss=[]
for i in range(len(state_of_interest)):
    steady_states.append([2**state_of_interest['A'].values[i], 2**state_of_interest['B'].values[i]])
    freq_ss.append(solutions['No. of Init Conds'].values[i]/10000)
#print("Steady States:", steady_states)
#print("Frequency of Steady States:", freq_ss)


def global_cov_matrix(steady_states, freq_ss, dimensions):
    M = len(steady_states)
    Mu_global = np.zeros(dimensions)

    # --- This loop is where the fix is needed ---
    for i in range(M):
        # Convert the list to a NumPy array BEFORE multiplying
        state_vector = np.array(steady_states[i]) 
        Mu_global += freq_ss[i] * state_vector  # Now it's a float * np.array

    # --- The rest of your logic was correct in principle ---
    sigma_global = np.zeros((dimensions, dimensions))

    for i in range(M):
        mean_vector = np.array(steady_states[i]) # Ensure it's an array here too
        mean_outer_product = np.outer(mean_vector, mean_vector)
        sigma_global += freq_ss[i] * mean_outer_product

    sigma_global -= np.outer(Mu_global, Mu_global)
    
    return Mu_global, sigma_global

Mu_global, sigma_global = global_cov_matrix(steady_states, freq_ss, 2)
print("Global Mean:", Mu_global)
print("Global Covariance Matrix:\n", sigma_global)

def pca_analysis(global_cov_matrix):
   eigevals, eigenvectors = eigh(global_cov_matrix)
   sorted_indices = np.argsort(eigevals)[::-1]  
   sorted_eigevals = eigevals[sorted_indices]
   sorted_eigenvectors = eigenvectors[:, sorted_indices]
   PC1 = sorted_eigenvectors[:, 0]
   PC2 = sorted_eigenvectors[:, 1]
   total_variance = np.sum(eigevals)
   explained_variance_ratio = eigevals[sorted_indices] / total_variance
   return PC1, PC2, explained_variance_ratio
   

#multiply the two principal components the way you would multiply two vectors
def multiply_principal_components(PC1, PC2):
    return np.dot(PC1, PC2)

def transformation_matrix(PC1, PC2):
    return np.column_stack((PC1, PC2))

def project_steady_states(steady_states, transformation_matrix):
    steady_states_array = np.array(steady_states)
    projections=[]
    for i in range(steady_states_array.shape[0]):
        projections.append(transformation_matrix.T @ steady_states_array[i])
    return projections

PC1, PC2, explained_variance_ratio = pca_analysis(sigma_global)
print(PC1)
print(PC2)
sample_transformation_matrix = transformation_matrix(PC1, PC2)
projections = project_steady_states(steady_states, sample_transformation_matrix)


X_grid, Y_grid = np.meshgrid(np.linspace(-100, 100, 10000), np.linspace(-100, 100, 10000))


def probabiliy_distribution(projected_steady_states,ss_frequencies):
    probability_surface=np.zeros((X_grid.shape[0], X_grid.shape[1]))
    for i in range(len(projected_steady_states)):
        mean_2d = projected_steady_states[i]
        weight = ss_frequencies[i]
        rv= multivariate_normal(mean=mean_2d, cov=np.array([[1,0], [0, 1]]))
        gaussian_surface = rv.pdf(np.dstack((X_grid, Y_grid)))
        probability_surface += weight * gaussian_surface
    return probability_surface

def potential_energy(probability_surface):
    return -np.log(np.maximum(probability_surface, 1e-100))

sample_probability_surface = probabiliy_distribution(projections, freq_ss)
sample_potential_energy = potential_energy(sample_probability_surface)

def calculate_barrier_height_2d(U, a1, a2, mu_pca_A, mu_pca_B):
    """
    Calculates the energy barrier height between two stable states on a 2D landscape.

    This function finds the potential energy of the two stable states and approximates
    the saddle point by finding the maximum potential along a straight line connecting them.
    This version uses only NumPy for the line profile calculation, without interpolation.

    Args:
        U (np.ndarray): The 2D array representing the potential energy landscape.
        a1 (np.ndarray): The 2D meshgrid array for the x-coordinates (PC1).
        a2 (np.ndarray): The 2D meshgrid array for the y-coordinates (PC2).
        mu_pca_A (np.ndarray): The 2D coordinates of the first stable state (valley A).
        mu_pca_B (np.ndarray): The 2D coordinates of the second stable state (valley B).

    Returns:
        dict: A dictionary containing the calculated barrier heights and other useful info.
    """
    
    # Step 7.1: Find the Potential of the Stable States
    col_idx_A = np.argmin(np.abs(a1[0, :] - mu_pca_A[0]))
    row_idx_A = np.argmin(np.abs(a2[:, 0] - mu_pca_A[1]))
    U_stable_A = U[row_idx_A, col_idx_A]
    
    col_idx_B = np.argmin(np.abs(a1[0, :] - mu_pca_B[0]))
    row_idx_B = np.argmin(np.abs(a2[:, 0] - mu_pca_B[1]))
    U_stable_B = U[row_idx_B, col_idx_B]

    # Step 7.2: Find an Approximate Saddle Point
    num_points = 200
    x_coords = np.linspace(a1[0, col_idx_A], a1[0, col_idx_B], num_points)
    y_coords = np.linspace(a2[row_idx_A, 0], a2[row_idx_B, 0], num_points)
    
    line_profile_U = []
    x_axis = a1[0, :]
    y_axis = a2[:, 0]

    for x_point, y_point in zip(x_coords, y_coords):
        col_idx = np.argmin(np.abs(x_axis - x_point))
        row_idx = np.argmin(np.abs(y_axis - y_point))
        line_profile_U.append(U[row_idx, col_idx])

    line_profile_U = np.array(line_profile_U)
    U_saddle = np.max(line_profile_U)
    saddle_idx = np.argmax(line_profile_U)
    saddle_coords = np.array([x_coords[saddle_idx], y_coords[saddle_idx]])

    # Step 7.3: Calculate Barrier Heights
    BH_A_to_B = U_saddle - U_stable_A
    BH_B_to_A = U_saddle - U_stable_B
    
    results = {
        "BH_A_to_B": BH_A_to_B,
        "BH_B_to_A": BH_B_to_A,
        "U_stable_A": U_stable_A,
        "U_stable_B": U_stable_B,
        "U_saddle": U_saddle,
        "saddle_coords": saddle_coords
    }
    
    return results
"""
# --- CALL THE NEW FUNCTION AND PRINT RESULTS ---
if len(projections) >= 2:
    # Use the function to calculate the barrier heights
    # Assumes the first two projections are the two states of interest
    mu_A_proj = projections[0]
    mu_B_proj = projections[1]

    barrier_results = calculate_barrier_height_2d(sample_potential_energy, X_grid, Y_grid, mu_A_proj, mu_B_proj)

    print("\n--- Barrier Height Analysis ---")
    for key, value in barrier_results.items():
        if isinstance(value, np.ndarray):
            print(f"  {key}: [{value[0]:.2f}, {value[1]:.2f}]")
        else:
            print(f"  {key}: {value:.4f}")
else:
    print("\n--- Barrier Height Analysis ---")
    print("  Not enough stable states found to calculate a barrier.")
"""
"""
#plot the saddle point and stable states on the 2d potential energy landscape
plt.figure(figsize=(10, 6))
plt.plot(mu_A_proj[0], mu_A_proj[1], 'ro', label='Stable State A',color='red')
plt.plot(mu_B_proj[0], mu_B_proj[1], 'bo', label='Stable State B',color='red')
plt.plot(barrier_results['saddle_coords'][0], barrier_results['saddle_coords'][1], 'go', label='Saddle Point',color='green')

plt.contourf(X_grid, Y_grid, sample_potential_energy, levels=50, cmap='viridis')
plt.colorbar(label='Potential Energy')
plt.title('Potential Energy Landscape')
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.show()

#plotting 3D surface
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X_grid, Y_grid, sample_potential_energy, cmap='viridis', edgecolor='none')  
ax.set_title('3D Potential Energy Landscape')
ax.set_xlabel('PC1')
ax.set_ylabel('PC2')
ax.set_zlabel('Potential Energy')
plt.colorbar(ax.plot_surface(X_grid, Y_grid, sample_potential_energy, cmap='viridis', edgecolor='none'), ax=ax, shrink=0.5, aspect=5)
plt.show()

#calculating the basin of attraction
"""






    

    



    


    









