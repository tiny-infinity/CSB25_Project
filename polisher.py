# state_polisher.py
"""
A module to refine the numerically imprecise steady states generated by RACIPE.

This module takes the output from RACIPE and uses a root-finding algorithm
to locate the true, high-precision fixed points of the system where the
rate of change is zero.
"""

import numpy as np
import pandas as pd
from sympy import symbols, Matrix, lambdify
from scipy.optimize import root

# --- Internal Helper Functions (Encapsulated within the module) ---

def _positive_regulation(in_var, tld, hill, fc_par):
    """Internal model for positive regulation."""
    K_n = tld**hill
    x_n = in_var**hill
    numerator = fc_par + (1.0 - fc_par) * (K_n / (x_n + K_n))
    return numerator / fc_par

def _negative_regulation(in_var, tld, hill, fc_par):
    """Internal model for negative regulation."""
    K_n = tld**hill
    x_n = in_var**hill
    regulation_strength = K_n / (x_n + K_n)
    return fc_par + (1.0 - fc_par) * regulation_strength

def _generate_odes(adjacency_matrix, gene_symbols, params_row):
    """
    Internal function to generate the symbolic ODEs for the system.
    """
    odes = []
    for i in range(len(gene_symbols)):
        regulated_gene = gene_symbols[i]
        production_term = float(params_row.get(f'Prod_of_{regulated_gene.name}', 50.0))
        k_deg = float(params_row.get(f'Deg_of_{regulated_gene.name}', 1.0))
        degradation_term = k_deg * regulated_gene
        regulation_product = 1
        for j in range(len(gene_symbols)):
            regulation_type = adjacency_matrix[i][j]
            if regulation_type != 0:
                regulator_gene = gene_symbols[j]
                param_prefix = f'of_{regulator_gene.name}To{regulated_gene.name}'
                s = float(params_row.get(f'Trd_{param_prefix}', 16.0))
                n = float(params_row.get(f'Num_{param_prefix}', 4.0))
                if regulation_type > 0:
                    l = float(params_row.get(f'Act_{param_prefix}', 10.0))
                    regulation_product *= _positive_regulation(regulator_gene, s, n, l)
                elif regulation_type < 0:
                    l = float(params_row.get(f'Inh_{param_prefix}', 0.1))
                    regulation_product *= _negative_regulation(regulator_gene, s, n, l)
        ode = production_term * regulation_product - degradation_term
        odes.append(ode)
    return odes

def _generate_drift_function(system_odes, gene_symbols):
    """
    Internal function to create a fast numerical drift function for the solver.
    """
    symbols_as_tuple = tuple(gene_symbols)
    f_numeric = lambdify(symbols_as_tuple, system_odes, modules="numpy")
    return lambda x: np.array(f_numeric(*x), dtype=np.float64)

# --- Public Functions ---

def polish_full_racipe_output(full_steady_state_df, full_parameter_df, adjacency_matrix, node_names):
    """
    Refines all steady states in a DataFrame that contains multiple parameter sets.

    Args:
        full_steady_state_df (pd.DataFrame): The complete steady state output from RACIPE.
        full_parameter_df (pd.DataFrame): The complete parameter output from RACIPE.
        adjacency_matrix (list of lists): The network topology.
        node_names (list of str): The names of the genes/nodes.

    Returns:
        tuple: A tuple containing:
            - final_polished_df (pd.DataFrame): A single DataFrame with all states polished.
            - all_reports (dict): A dictionary where keys are parameter IDs and values are
                                  the polishing reports for that parameter set.
    """

    unique_param_ids = full_steady_state_df['PS.No'].unique()
    
    all_polished_dfs = []
    all_reports = {}

    print(f"Found {len(unique_param_ids)} unique parameter sets to polish.")

    for param_id in unique_param_ids:
        print(f"\n{'='*20} Processing Parameter Set ID: {param_id} {'='*20}")
        
        # Get the specific parameter row for the current ID
        params_row = full_parameter_df.loc[full_parameter_df['PS.No'] == param_id]
        if params_row.empty or param_id==1:
            print(f"  Warning: No parameter data found for ID {param_id}. Skipping.")
            continue
        params_row = params_row.iloc[0]
        
        # Get the subset of steady states for this parameter ID
        ss_subset_df = full_steady_state_df.loc[full_steady_state_df['PS.No'] == param_id]
        
        # Use the existing function to polish this subset
        polished_subset, report = polish_racipe_dataframe(
            ss_subset_df,
            adjacency_matrix,
            params_row,
            node_names
        )
        
        all_polished_dfs.append(polished_subset)
        all_reports[param_id] = report

    if not all_polished_dfs:
        print("No parameter sets were processed.")
        return pd.DataFrame(), {}

    # Combine all polished DataFrames back into one
    final_polished_df = pd.concat(all_polished_dfs)
    
    return final_polished_df, all_reports


def polish_racipe_dataframe(racipe_df, adjacency_matrix, params_row, node_names):
    """
    Refines all steady states within a RACIPE pandas DataFrame for a SINGLE parameter set.

    Args:
        racipe_df (pd.DataFrame): DataFrame containing steady states from RACIPE for one parameter set.
        adjacency_matrix (list of lists): The network topology.
        params_row (pd.Series): The parameter set for the given model.
        node_names (list of str): The names of the genes/nodes.

    Returns:
        tuple: A tuple containing:
            - polished_df (pd.DataFrame): A new DataFrame with the polished steady-state values.
            - report (list of dict): A summary of the polishing process for each state.
    """
    # 1. Extract the linear-scale vectors from the input DataFrame
    racipe_vectors = []
    for _, row in racipe_df.iterrows():
        log_values = [float(row[var]) for var in node_names]
        racipe_vectors.append(2**np.array(log_values, dtype=np.float64))

    # 2. Call the core polishing function
    polished_vectors, report = polish_steady_states(
        racipe_vectors, adjacency_matrix, params_row, node_names
    )

    # 3. Construct a new DataFrame with the polished values
    polished_df = racipe_df.copy()
    for i, p_vec in enumerate(polished_vectors):
        # Convert polished vectors back to log2 scale for the DataFrame
        log2_polished_vec = np.log2(np.maximum(p_vec, 1e-12)) # Add epsilon for stability
        for j, name in enumerate(node_names):
            polished_df.iloc[i, polished_df.columns.get_loc(name)] = log2_polished_vec[j]
    
    return polished_df, report


def polish_steady_states(racipe_vectors, adjacency_matrix, params_row, node_names):
    """
    Refines a list of RACIPE steady state vectors to find true, high-precision fixed points.
    """
    # print("--- Initializing State Polishing ---")
    
    # 1. Set up the system dynamics
    gene_symbols = symbols(node_names)
    odes = _generate_odes(adjacency_matrix, gene_symbols, params_row)
    drift_function = _generate_drift_function(odes, gene_symbols)

    polished_states = []
    report = []

    # 2. Loop through each RACIPE state and polish it
    for i, initial_guess in enumerate(racipe_vectors):
        # print(f"\nPolishing state #{i+1}...")
        
        initial_drift = np.linalg.norm(drift_function(initial_guess))
        
        # Use the root finder with the RACIPE state as the initial guess
        solution = root(drift_function, initial_guess, method='hybr')

        state_report = {
            "state_index": i,
            "initial_guess": initial_guess,
            "initial_drift_norm": initial_drift,
            "converged": solution.success
        }
        
        if solution.success:
            final_vector = solution.x
            # Ensure the solution is non-negative
            final_vector[final_vector < 0] = 0
            final_drift = np.linalg.norm(drift_function(final_vector))
            
            polished_states.append(final_vector)
            state_report["polished_vector"] = final_vector
            state_report["final_drift_norm"] = final_drift
            # print(f"  Success! Initial drift: {initial_drift:.2e} -> Final drift: {final_drift:.2e}")
        else:
            # If polishing fails, use the original vector as a fallback
            polished_states.append(initial_guess)
            state_report["polished_vector"] = initial_guess # Fallback
            state_report["final_drift_norm"] = initial_drift # Unchanged
            state_report["message"] = solution.message
            # print(f"  Warning: Root-finding failed. {solution.message}. Using original vector.")
        
        report.append(state_report)

    # print("\n--- State Polishing Complete ---")
    return polished_states, report

# --- Example Usage ---

if __name__ == '__main__':
    # This block demonstrates how to use the module.
    
    try:
        from make_sense_of_RACIPE import steady_states, parameter_set
    except ImportError:
        print("Could not import RACIPE data. Please run from the main project directory.")
        exit()

    # 1. Define the system to analyze
    network_name = "MISA"
    node_names = ['A', 'B']
    adjacency_matrix = [[1, -1], [-1, 1]]

    # 2. Load the FULL data from RACIPE (not just for one param_id)
    full_params_df = parameter_set(network_name)
    full_ss_df = steady_states(network_name, node_names)
    
    # Optional: If the DataFrames are very large, take a small slice for testing
    # For example, let's process the first 2 parameter sets that have steady states
    test_param_ids = full_ss_df['PS.No'].unique()
    test_ss_df = full_ss_df[full_ss_df['PS.No'].isin(test_param_ids)]

    # 3. Call the new top-level function to polish the entire DataFrame
    if not test_ss_df.empty:
        final_polished_df, all_reports = polish_full_racipe_output(
            full_steady_state_df=test_ss_df,
            full_parameter_df=full_params_df,
            adjacency_matrix=adjacency_matrix,
            node_names=node_names
        )

        # 4. Print a high-level summary
        print("\n--- Final Polishing Summary ---")
        for param_id, report_list in all_reports.items():
            success_count = sum(1 for r in report_list if r['converged'])
            print(f"Parameter Set ID {param_id}: Polished {success_count}/{len(report_list)} states successfully.")

        print("\n--- Comparison for first processed parameter set ---")
        first_param_id = list(all_reports.keys())[0]
        original_subset = test_ss_df[test_ss_df['PS.No'] == first_param_id]
        polished_subset = final_polished_df[final_polished_df['PS.No'] == first_param_id]
        
        print("\nOriginal RACIPE states:")
        print(original_subset[node_names + ['PS.No']])
        print("\nPolished states:")
        print(polished_subset[node_names + ['PS.No']])
        
    else:
        print("No steady states found to process.")
    print(final_polished_df)
